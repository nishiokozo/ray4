#include <iostream>
#include <cmath>

#include "geom.h"

using namespace std;


//-----------------------------------------------------------------------------
float mat33::det()
//-----------------------------------------------------------------------------
{
	// 行列式の値
	// | a b c |
	// | d e f | = a| e f | - d| b c | + g| b c |
	// | g h i |    | h i |    | h i |    | e f |

	// | 00 01 02 |
	// | 10 11 12 | = 00| 11 12 | - 10| 01 02 | + 20| 01 02 |
	// | 20 21 22 |     | 21 22 |     | 21 22 |     | 11 12 |

	return
		 m[0][0]*(	 m[1][1] * m[2][2]
					-m[2][1] * m[1][2]	)

		-m[1][0]*(	 m[0][1] * m[2][2]
					-m[2][1] * m[0][2]	)

		+m[2][0]*(	 m[0][1] * m[1][2]
					-m[1][1] * m[0][2]	)
		;
}

//-----------------------------------------------------------------------------
mat33 mat33::transpose()
//-----------------------------------------------------------------------------
{
	// 転置行列
	return mat33(
		m[0][0], m[1][0], m[2][0],
		m[0][1], m[1][1], m[2][1],
		m[0][2], m[1][2], m[2][2]
	);
}

//-----------------------------------------------------------------------------
mat33 mat33::invers()
//-----------------------------------------------------------------------------
{
	// 逆行列
#if 1
	//随伴法

	float m00 = m[0][0];
	float m01 = m[0][1];
	float m02 = m[0][2];
	float m10 = m[1][0];
	float m11 = m[1][1];
	float m12 = m[1][2];
	float m20 = m[2][0];
	float m21 = m[2][1];
	float m22 = m[2][2];

	//余因子を求める
	float c00 =  (	 m11 * m22
					-m21 * m12	);

	float c01 = -(	 m10 * m22
					-m20 * m12	);

	float c02 =  (	 m10 * m21
					-m20 * m11	);

	float c10 = -(	 m01 * m22
					-m21 * m02	);

	float c11 =  (	 m00 * m22
					-m20 * m02	);

	float c12 = -(	 m00 * m21
					-m20 * m01	);

	float c20 =  (	 m01 * m12
					-m11 * m02	);

	float c21 = -(	 m00 * m12
					-m10 * m02	);

	float c22 =  (	 m00 * m11
					-m10 * m01	);

	//随伴行列は余因子行列の転置
	mat33 a(
		c00, c01, c02,
		c10, c11, c12,
		c20, c21, c22
	);
	mat33 adjM = a.transpose();

	// 随伴行列を行列会式で割ることで逆行列が求まる
	
	return adjM / a.det();

#else
	//掃き出し法
	//横長の行列(AI) に行基本変形を繰り返し行って(IB) になったら，B は A の逆行列である。	

	mat33 A(*this);
	mat33 I(1,0,0, 0,1,0, 0,0,1);
	
	int d = 3;  //配列の次数

	for( int i = 0 ; i < d ; i++ )
	{
		float f = 1/A.m[i][i];
		for( int j=0 ; j < d ; j++ )
		{
			A.m[i][j] *= f;
			I.m[i][j] *= f;
		}
		for( int j=0 ; j < d ; j++ )
		{
			if(i!=j)
			{
				f = A.m[j][i];
				for( int k=0 ; k < d ; k++ )
				{
					A.m[j][k] -= A.m[i][k] * f;
					I.m[j][k] -= I.m[i][k] * f;
				}
			}
		}
	}


	return I;
#endif

}
//-----------------------------------------------------------------------------
mat43 mat43::invers()
//-----------------------------------------------------------------------------
{
	{

		mat44 A(
			m[0][0],	m[0][1],	m[0][2],	0.0,
			m[1][0],	m[1][1],	m[1][2],	0.0,
			m[2][0],	m[2][1],	m[2][2],	0.0,
			pos[0],		pos[1],		pos[2],		1.0
		);
		mat44 I(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
		
		int z1=4;  //配列の次数

		//掃き出し法
		for( int i = 0 ; i < z1 ; i++ )
		{
			float f =1/A.m[i][i];
			for( int j = 0 ; j < z1 ; j++ )
			{
				A.m[i][j] *= f;
				I.m[i][j] *= f;
			}
			for( int j = 0 ; j < z1 ; j++ )
			{
				if( i !=j )
				{
					f= A.m[j][i];
					for( int k = 0 ; k < z1 ; k++ )
					{
						A.m[j][k] -= A.m[i][k]*f;
						I.m[j][k] -= I.m[i][k]*f;
					}
				}
			}
		}
		return mat43
		(
			I.m[0][0],	I.m[0][1],	I.m[0][2],
			I.m[1][0],	I.m[1][1],	I.m[1][2],
			I.m[2][0],	I.m[2][1],	I.m[2][2],
			I.m[3][0],	I.m[3][1],	I.m[3][2]
		);
		
	}

}
//-----------------------------------------------------------------------------
mat44 mat44::invers()
//-----------------------------------------------------------------------------
{
	{
	#if 1

		mat44 A(*this);
		mat44 I(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
		
		int z1=4;  //配列の次数

		//掃き出し法
		for( int i = 0 ; i < z1 ; i++ )
		{
			float f =1/A.m[i][i];
			for( int j = 0 ; j < z1 ; j++ )
			{
				A.m[i][j] *= f;
				I.m[i][j] *= f;
			}
			for( int j = 0 ; j < z1 ; j++ )
			{
				if( i !=j )
				{
					f= A.m[j][i];
					for( int k = 0 ; k < z1 ; k++ )
					{
						A.m[j][k] -= A.m[i][k]*f;
						I.m[j][k] -= I.m[i][k]*f;
					}
				}
			}
		}
		return I;
	#else
		float a[4][4];

		a[0][0] = m[0][0];
		a[0][1] = m[0][1]; 
		a[0][2] = m[0][2]; 
		a[0][3] = m[0][3]; 
		a[1][0] = m[1][0]; 
		a[1][1] = m[1][1]; 
		a[1][2] = m[1][2]; 
		a[1][3] = m[1][3]; 
		a[2][0] = m[2][0]; 
		a[2][1] = m[2][1]; 
		a[2][2] = m[2][2]; 
		a[2][3] = m[2][3]; 
		a[3][0] = m[3][0]; 
		a[3][1] = m[3][1]; 
		a[3][2] = m[3][2]; 
		a[3][3] = m[3][3]; 

		mat44 inv_a;
		
		float buf; //一時的なデータを蓄える
		int i,j,k; //カウンタ
		int z1=4;  //配列の次数

		//単位行列を作る
		for(i=0;i<z1;i++)
		{
			for(j=0;j<z1;j++)
			{
				inv_a.m[i][j]=(i==j)?1.0:0.0;
			}
		}
		//掃き出し法
		for(i=0;i<z1;i++)
		{
			buf=1/a[i][i];
			for(j=0;j<z1;j++)
			{
				a[i][j]*=buf;
				inv_a.m[i][j]*=buf;
			}
			for(j=0;j<z1;j++)
			{
				if(i!=j)
				{
					buf=a[j][i];
					for(k=0;k<z1;k++)
					{
						a[j][k]-=a[i][k]*buf;
						inv_a.m[j][k]-=inv_a.m[i][k]*buf;
					}
				}
			}
		}
		return inv_a;
	#endif
	}
}



//-----------------------------------------------------------------------------
mat33 mslerp( vect3 n1, float range )
//-----------------------------------------------------------------------------
{
	vect3	n0 = vect3(0,0,1); //mrotateByAxis の基軸がzなので(0,0,1)
	vect3	bn = cross(n0,n1);
	float	th = acos( dot(n0,n1) );
	return  mrotateByAxis( bn, th*range );

};

//-----------------------------------------------------------------------------
mat33 mrotateByAxis( vect3 axis, float th )
//-----------------------------------------------------------------------------
{
	// axis軸回りにth°回転する行列を返す。
	//
	// axisは正規化されてなくても良い。

	// z軸をaixsに合わせたマトリクスを作り
	float ry	= atan2( axis.x , axis.z);
	float lxz	= sqrt( axis.z * axis.z + axis.x * axis.x );
	float rz	= atan2( axis.y, lxz );
	mat33 mr = midentity();
	mr *= mrotx(-rz);
	mr *= mroty(ry);

	mat33 m = midentity();
	// 作成した行列のz軸で回転
	m *= mr.invers();
	m *= mrotz(th);
	m *= mr;

	return m;
};

//-----------------------------------------------------------------------------
float	mod( float a, float b )
//-----------------------------------------------------------------------------
{
	return fmod(a,b);
}

//-----------------------------------------------------------------------------
vect2	ave( vect2 a, vect2 b )
//-----------------------------------------------------------------------------
{
	return	(a+b)/2;
}

//-----------------------------------------------------------------------------
vect3	ave( vect3 a, vect3 b )
//-----------------------------------------------------------------------------
{
	return	(a+b)/2;
}

//-----------------------------------------------------------------------------
float	min( float a, float b )
//-----------------------------------------------------------------------------
{
	if ( a < b ) return a;
	return	b;
}

//-----------------------------------------------------------------------------
float	max( float a, float b )
//-----------------------------------------------------------------------------
{
	if ( a > b ) return a;
	return	b;
}
//-----------------------------------------------------------------------------
vect2	max( vect2 a, vect2 b )
//-----------------------------------------------------------------------------
{
	vect2	ret=b;
	if ( a.x > b.x ) ret.x = a.x;
	if ( a.y > b.y ) ret.y = a.y;
	return	ret;
}
//-----------------------------------------------------------------------------
vect2	min( vect2 a, vect2 b )
//-----------------------------------------------------------------------------
{
	vect2	ret=b;
	if ( a.x < b.x ) ret.x = a.x;
	if ( a.y < b.y ) ret.y = a.y;
	return	ret;
}
//-----------------------------------------------------------------------------
vect3	max( vect3 a, vect3 b )
//-----------------------------------------------------------------------------
{
	vect3	ret=b;
	if ( a.x > b.x ) ret.x = a.x;
	if ( a.y > b.y ) ret.y = a.y;
	if ( a.z > b.z ) ret.z = a.z;
	return	ret;
}
//-----------------------------------------------------------------------------
vect3	min( vect3 a, vect3 b )
//-----------------------------------------------------------------------------
{
	vect3	ret=b;
	if ( a.x < b.x ) ret.x = a.x;
	if ( a.y < b.y ) ret.y = a.y;
	if ( a.z < b.z ) ret.z = a.z;
	return	ret;
}


//-----------------------------------------------------------------------------
vect3	max( float a, vect3 b )
//-----------------------------------------------------------------------------
{
	vect3	ret;
	ret = b;
	if ( a > b.x ) ret.x = a;
	if ( a > b.y ) ret.y = a;
	if ( a > b.z ) ret.z = a;
	return	ret;
}

//-----------------------------------------------------------------------------
vect3	max( vect3 b, float a )
//-----------------------------------------------------------------------------
{
	vect3	ret;
	ret = b;
	if ( a > b.x ) ret.x = a;
	if ( a > b.y ) ret.y = a;
	if ( a > b.z ) ret.z = a;
	return	ret;
}

//-----------------------------------------------------------------------------
vect3	min( float a, vect3 b )
//-----------------------------------------------------------------------------
{
	vect3	ret;
	ret = b;
	if ( a < b.x ) ret.x = a;
	if ( a < b.y ) ret.y = a;
	if ( a < b.z ) ret.z = a;
	return	ret;
}

//-----------------------------------------------------------------------------
vect3	min( vect3 b, float a )
//-----------------------------------------------------------------------------
{
	vect3	ret;
	ret = b;
	if ( a < b.x ) ret.x = a;
	if ( a < b.y ) ret.y = a;
	if ( a < b.z ) ret.z = a;
	return	ret;
}

//-----------------------------------------------------------------------------
vect3	mix( float f, vect3 a, vect3 b )
//-----------------------------------------------------------------------------
{
	vect3	ret;

	ret = a*f + b*(1.0f-f);

	return ret;
}

//-----------------------------------------------------------------------------
vect3 reflect( vect3 I, vect3 N )
//-----------------------------------------------------------------------------
{
	// Iは自由ベクトル
	// Nは単位ベクトル

	return I - 2* dot(I,N)*N;
}

//-----------------------------------------------------------------------------
vect3 refract( vect3 I, vect3 N, float eta )
//-----------------------------------------------------------------------------
{
//https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml
//
// I Specifies the incident vector.
// 
// N Specifies the normal vector.
// 
// eta Specifies the ratio of indices of refraction.
// 
//
//    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));
//    if (k < 0.0)
//        R = genType(0.0);
//    else
//        R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;
		vect3	R;
#if 1
	float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));
	if ( k < 0.0 )
	{
		R = vect3(0,0,0);
	}
	else
	{
		R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;
	}
#else

	#if 1
		float	n1 = 1.0;
		float	n2 = eta;
		float	d = dot(-I,N);

		R = (n1/n2)*(I-N*(sqrt((n2/n1)*(n2/n1)-1+d*d)-d));
	#else

	 #if 0
	//R = (n*I*cosθ + n*N - m*N)/(m*cosφ)
		float	n = 1.0;
		float	m = eta;
		float	d = dot(I,-N); // cosθ


		R = (n*I*d + n*N - m*N)/(m*d);
	 #else
	//R = (n*N*cosθ + n*I - m*N*cosφ)/m
		float	n = 1.0;
		float	m = eta;
		float	d = dot(I,-N); // cosθ

		R = (n*N*d + n*I - m*N*d)/m


	 #endif


		
	#endif
#endif

	return R;
}

//-----------------------------------------------------------------------------
float	dot( vect2 a, vect2 b )
//-----------------------------------------------------------------------------
{
	return a.x * b.x + a.y * b.y;
}

//-----------------------------------------------------------------------------
float	dot( vect3 a, vect3 b )
//-----------------------------------------------------------------------------
{
	/*
		※よく使う内積のTips

		①２つのベクトルの織りなす角を求める

			int main()
			{
				vect3 a,b;

				float	ao = deg2rad(10+32);
				float	ar = 1.0;

				float	bo = deg2rad(10+0);
				float	br = 1.0;

				a.x = ar * cos(ao);
				a.y = ar * sin(ao);
				b.x = br * cos(bo);
				b.y = br * sin(bo);

				cout << rad2deg( acos( dot(a,b) ) ) << endl;

			}
			--
			32
			
			条件）両方のベクトルが単位ベクトルであること




		②投影長さを求める

			int main()
			{
				vect3 a,b;

				float	ao = deg2rad(10+45);
				float	ar = 2.0;

				float	bo = deg2rad(10+0);
				float	br = 1.0;

				a.x = ar * cos(ao);
				a.y = ar * sin(ao);
				b.x = br * cos(bo);
				b.y = br * sin(bo);

				cout << dot(a,b) << endl;

			}
			---
			1.14142

			条件）少なくとも一方が単位ベクトルであること




		②-b 投影ベクトル求める
	
			 dot(a,b) * b;

			条件）bが単位ベクトルであること




		③ベクトルの長さを求める（ベクトルの絶対値を求める）

			int main()
			{
				vect3 a,b;

				float	ao = deg2rad(10+32);
				float	ar = 123.45;

				a.x = ar * cos(ao);
				a.y = ar * sin(ao);

				cout << sqrt( dot(a,a) ) << endl;

			}
			---
			123.45

			条件）最後に要平方根
			
			※）a.abs() と同じ

	*/

	return a.x * b.x + a.y * b.y +a.z * b.z ;
}
//-----------------------------------------------------------------------------
vect3	cross( vect3 a, vect3 b )
//-----------------------------------------------------------------------------
{
	// z = cross( x, y )

#if 0
	vect3 v; 
	v.x = a.y*b.z-a.z*b.y;
	v.y = a.z*b.x-a.x*b.z;
	v.z = a.x*b.y-a.y*b.x;
	return v;
#else
	return vect3(
		a.y*b.z-a.z*b.y,
		a.z*b.x-a.x*b.z,
		a.x*b.y-a.y*b.x
	);
#endif
}

//-----------------------------------------------------------------------------
vect3	normalize( vect3 a )
//-----------------------------------------------------------------------------
{
	vect3 v; 
	float	l = 1.0 / sqrt( a.x*a.x + a.y*a.y + a.z*a.z );
	
	v.x = a.x * l;
	v.y = a.y * l;
	v.z = a.z * l;

	return	v;
}

#define	M00	0
#define	M01	1
#define	M02	2
#define	M03	3
#define	M10	4
#define	M11	5
#define	M12	6
#define	M13	7
#define	M20	8
#define	M21	9
#define	M22	10
#define	M23	11
#define	M30	12
#define	M31	13
#define	M32	14
#define	M33	15

//-----------------------------------------------------------------------------
void	mat4_ortho( float* m, float x1, float x2, float y1, float y2, float z1, float z2 )
//-----------------------------------------------------------------------------
{
	float sx =  (2.0     )/( x2 - x1 );
	float sy =  (2.0     )/( y2 - y1 );
	float sz = -(2.0     )/( z2 - z1 );
	float tx =  -(x2+x1)/(x2-x1);
	float ty =  -(y2+y1)/(y2-y1);
	float tz =  -(z2+z1)/(z2-z1);


	m[ 0] =   sx;	m[ 1] = 0.0f;	m[ 2] = 0.0f;	m[ 3] = 0.0f;
	m[ 4] = 0.0f;	m[ 5] =   sy;	m[ 6] = 0.0f;	m[ 7] = 0.0f;
	m[ 8] = 0.0f;	m[ 9] = 0.0f;	m[10] =   sz;	m[11] = 0.0f;
	m[12] =   tx;	m[13] =   ty;	m[14] =   tz;	m[15] = 1.0f;
}
//-----------------------------------------------------------------------------
void mat4_perspective (float* m, float fovy, float aspect, float zNear, float zFar)
//-----------------------------------------------------------------------------
{
        float p = 1.0 / tan(fovy * (pi/360.0));

/*
        m[0] = z2 / aspect;
        m[1] = 0.0;
        m[2] = 0.0;
        m[3] = 0.0;

        m[4] = 0.0;
        m[5] = z2;
        m[6] = 0.0;
        m[7] = 0.0;

        m[8] = 0.0;
        m[9] = 0.0;
        m[10] = (zFar + zNear) / (zNear - zFar);
        m[11] = -1.0;

        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = 2.0 * zFar * zNear / (zNear - zFar);
        m[15] = 0.0;
*/

/*
	float	p = {
        z2 / aspect,	0.0,	0.0,									 0.0,
        0.0,		z2,		0.0,									 0.0,
        0.0,        0.0,    (zFar + zNear) / (zNear - zFar),        -1.0,
 		0.0,        0.0,	2.0 * zFar * zNear / (zNear - zFar),	 0.0
	};

	mat4_copy( m, p );
*/
	float	z2 = zFar;
	float	z1 = zNear;


        m[ 0] = p / aspect; m[ 1] = 0.0;	m[ 2] = 0.0;        			m[ 3] =  0.0;
        m[ 4] = 0.0;        m[ 5] = p;    	m[ 6] = 0.0;        			m[ 7] =  0.0;
        m[ 8] = 0.0;        m[ 9] = 0.0;  	m[10] = (z2+z1)         / (z1-z2); 	m[11] = -1.0;
        m[12] = 0.0;    	m[13] = 0.0;	m[14] = (2.0 * z2 * z1) / (z1-z2);  m[15] =  0.0;


/*
float w = z2 / aspect;
float h = z2;
float c = (zFar + zNear) / (zNear - zFar);
float d = 2.0 * zFar * zNear / (zNear - zFar);
          w,	0.0,	 0.0,	 0.0,
        0.0,	  h,	 0.0,	 0.0,
        0.0,    0.0,       c,      d,
 		0.0,    0.0,	-1.0,	 0.0
	};

	mat4_copy( m, p );
*/

}
//-----------------------------------------------------------------------------
void mat4_ray_perspective (float* m, float fovy, float aspect )
//-----------------------------------------------------------------------------
{
        float	p = 1.0f / tan(fovy * (pi/360.0));
		float	ofs_x = 0.0;	//x	offset-x
		float	ofs_y = 0.0;	//y	offset-y
		float	ofs_z = -p;		//z	offset-z


        m[ 0] = 1.0* aspect;m[ 1] = 0.0;    m[ 2] = 0.0;    m[ 3] = 0.0;
        m[ 4] = 0.0;  		m[ 5] = 1.0;    m[ 6] = 0.0;    m[ 7] = 0.0;
        m[ 8] = 0.0;        m[ 9] = 0.0;    m[10] = 1.0;    m[11] = 0.0;
        m[12] = ofs_x;      m[13] = ofs_y;	m[14] = ofs_z;	m[15] = 0.0;

}

//-----------------------------------------------------------------------------
void mat4_glFrustumf ( float* m,  float x1, float x2, float y1, float y2, float z1, float z2)
//-----------------------------------------------------------------------------
{
    m[ 0] = (2*z1) / (x2-x1);	m[ 1] = 0.0;         	m[ 2] = 0.0;        		m[ 3] = 0.0;
    m[ 4] = 0.0;       	 	m[ 5] = (2*z1) / (y2-y1);	m[ 6] = 0.0;        		m[ 7] = 0.0;
    m[ 8] = (x2+x1) / (x2-x1);	m[ 9] = (y2+y1) / (y2-y1); 	m[10] = -(z2+z1) / (z2-z1);     m[11] =-1.0;
    m[12] = 0.0;         	m[13] = 0.0;         	m[14] = -(2*z1*z2) / (z2-z1);   m[15] = 0.0;

}
//-----------------------------------------------------------------------------
void	mat4_frustum( float* m, float x1, float x2, float y1, float y2, float z1, float z2 )
//-----------------------------------------------------------------------------
{
	float sx =       (2.0f * z1) / (x2-x1);
	float sy =       (2.0f * z1) / (y2-y1);
	float mx =           (x2+x1) / (x2-x1);
	float my =           (y2+y1) / (y2-y1);
	float sz =          -(z2+z1) / (z2-z1);
	float w  = -(2.0 * z2 * z1 ) / (z2-z1);
	m[M00] =   sx;	m[M01] = 0.0f;	m[M02] =  mx;	m[M03] = 0.0f;
	m[M10] = 0.0f;	m[M11] =   sy;	m[M12] =  my;	m[M13] = 0.0f;
	m[M20] = 0.0f;	m[M21] = 0.0f;	m[M22] =  sz;	m[M23] =    w;
	m[M30] = 0.0f;	m[M31] = 0.0f;	m[M32] =-1.0f;	m[M33] = 0.0f;
}
//-----------------------------------------------------------------------------
void	mat4_Frustum( mat44& m, float x1, float x2, float y1, float y2, float z1, float z2 )
//-----------------------------------------------------------------------------
{
//	float* a = m.m_array;
	float* a = &m.m[0][0];


	float sx =    2.0f / (x2-x1);
	float sy =    2.0f / (y2-y1);
	float sz =    2.0f / (z2-z1);
//	float tx = (x2+x1) / (x2-x1);
//	float ty = (y2+y1) / (y2-y1);
//	float tz = (z2+z1) / (z2-z1);
	
	float w = 1.0f/z1;
	
	sx = 1.0f;
	sy = 1.0f;
	sz = 1.0f;
	w = 1.0f/2.0f;


	a[M00] =   sx;	a[M01] = 0.0f;	a[M02] = 0.0f;	a[M03] = 0.0f;
	a[M10] = 0.0f;	a[M11] =   sy;	a[M12] = 0.0f;	a[M13] = 0.0f;
	a[M20] = 0.0f;	a[M21] = 0.0f;	a[M22] =   sz;	a[M23] =    w;
	a[M30] = 0.0f;	a[M31] = 0.0f;	a[M32] = 0.0f;	a[M33] = 0.0f;

}
//-----------------------------------------------------------------------------
void	mat4_Ortho( mat44& m, float x1, float x2, float y1, float y2, float z1, float z2 )
//-----------------------------------------------------------------------------
{
	float* a = &m.m[0][0];

	float sx =    2.0f / (x2-x1);
	float sy =    2.0f / (y2-y1);
	float sz =    2.0f / (z2-z1);
	float tx = (x2+x1) / (x2-x1);
	float ty = (y2+y1) / (y2-y1);
	float tz = (z2+z1) / (z2-z1);
	a[M00] =   sx;	a[M01] = 0.0f;	a[M02] = 0.0f;	a[M03] = 0.0f;
	a[M10] = 0.0f;	a[M11] =   sy;	a[M12] = 0.0f;	a[M13] = 0.0f;
	a[M20] = 0.0f;	a[M21] = 0.0f;	a[M22] =   sz;	a[M23] = 0.0f;
	a[M30] =   tx;	a[M31] =   ty;	a[M32] =   tz;	a[M33] = 1.0f;
}
//-----------------------------------------------------------------------------
void	mat4_Ortho( float* m, float x1, float x2, float y1, float y2, float z1, float z2 )
//-----------------------------------------------------------------------------
{

	float sx =    2.0f / (x2-x1);
	float sy =    2.0f / (y2-y1);
	float sz =    2.0f / (z2-z1);
	float tx = (x2+x1) / (x2-x1);
	float ty = (y2+y1) / (y2-y1);
	float tz = (z2+z1) / (z2-z1);
	m[M00] =   sx;	m[M01] = 0.0f;	m[M02] = 0.0f;	m[M03] = 0.0f;
	m[M10] = 0.0f;	m[M11] =   sy;	m[M12] = 0.0f;	m[M13] = 0.0f;
	m[M20] = 0.0f;	m[M21] = 0.0f;	m[M22] =   sz;	m[M23] = 0.0f;
	m[M30] =   tx;	m[M31] =   ty;	m[M32] =   tz;	m[M33] = 1.0f;
}

//-----------------------------------------------------------------------------
float atan2_360( float y, float x )
//-----------------------------------------------------------------------------
{
//	return	((n)*pi/180.0f);
	return 0;
}

//-----------------------------------------------------------------------------
float deg2rad( float n )
//-----------------------------------------------------------------------------
{
	return	((n)*pi/180.0f);
}

//-----------------------------------------------------------------------------
float rad( float n )
//-----------------------------------------------------------------------------
{
	return	((n)*pi/180.0f);
}

//-----------------------------------------------------------------------------
float	rad2deg( float n)
//-----------------------------------------------------------------------------
{
	return ((n)*180.0f/pi);
}

//-----------------------------------------------------------------------------
mat33 midentity()
//-----------------------------------------------------------------------------
{
	return mat33(
		1,  0,  0,
		0,  1,  0,
		0,  0,  1
	);
}
///////////////////////////////////////
//	                                 //
//      マトリクスの回転の関係性     //
//	 	             	             //
//                y ->               //
//                .		             //
//                .		             //
//                .		             //
//                .		             //
//          ^   .   .   		     //
//          | .       . 	         //
//          x        <- z 	         //
//	                                 //
//	         ※左ねじの法則          //
//	                                 //
///////////////////////////////////////

//-----------------------------------------------------------------------------
mat33 mrotx( float f )
//-----------------------------------------------------------------------------
{
	// f : atan2(Z,Y)=atan2(0,1)=0	Y->Zへ回転

	float	c = cos(f);
	float	s = sin(f);
	return mat33(
		1,  0,  0,
		0,  c,  s,
		0, -s,  c
	);
}

//-----------------------------------------------------------------------------
mat33 mroty( float f )
//-----------------------------------------------------------------------------
{
	// f : atan2(X,Z)=atan2(0,1)=0	Z->Xへ回転

	float	c = cos(f);
	float	s = sin(f);
	return mat33(
		c,  0, -s,
		0,  1,  0,
	    s,  0,  c
	);
}

//-----------------------------------------------------------------------------
mat33 mrotz( float f )
//-----------------------------------------------------------------------------
{
	// f : atan2(Y,X)=atan2(0,1)=0	X->Yへ回転

	float	c = cos(f);
	float	s = sin(f);
	return mat33(
		c,  s,  0,
	   -s,	c,  0,
		0,  0,  1
	);
}



//-----------------------------------------------------------------------------
mat44 mat44::midentity()
//-----------------------------------------------------------------------------
{
	return mat44(
		1,  0,  0,	0,
		0,  1,  0,	0,
		0,  0,  1,	0,
		0,	0,  0,  1
	);
}

//-----------------------------------------------------------------------------
mat44 mat44::mrotx( float f )
//-----------------------------------------------------------------------------
{
	// f : atan2(Z,Y)=atan2(0,1)=0	Y->Zへ回転

	float	c = cos(f);
	float	s = sin(f);
	return mat44(
		1,  0,  0,	0,
		0,  c,  s,	0,
		0, -s,  c,	0,
		0,	0,	0,	1
	);
}

//-----------------------------------------------------------------------------
mat44 mat44::mroty( float f )
//-----------------------------------------------------------------------------
{
	// f : atan2(X,Z)=atan2(0,1)=0	Z->Xへ回転

	float	c = cos(f);
	float	s = sin(f);
	return mat44(
		c,  0, -s,	0,
		0,  1,  0,	0,
	    s,  0,  c,	0,
		0,	0,	0,	1
	);
}

//-----------------------------------------------------------------------------
mat44 mat44::mrotz( float f )
//-----------------------------------------------------------------------------
{
	// f : atan2(Y,X)=atan2(0,1)=0	X->Yへ回転

	float	c = cos(f);
	float	s = sin(f);
	return mat44(
		c,  s,  0,	0,
	   -s,	c,  0,	0,
		0,  0,  1,	0,
		0,	0,	0,	1
	);
}

